# üîç ValidationPipe ‚Äî Middleware de Validaci√≥n Avanzado

## üìã Descripci√≥n

Middleware robusto que transforma y valida datos de peticiones HTTP (body, query, params) usando **class-validator** y **class-transformer**. Se integra con el sistema centralizado de errores para un manejo consistente y profesional.

## ‚úÖ Caracter√≠sticas Principales

- ‚úÖ **Validaci√≥n de m√∫ltiples fuentes**: body, query parameters, route params
- ‚úÖ **Transformaci√≥n autom√°tica**: Convierte plain objects a instancias de clase tipadas
- ‚úÖ **Whitelist autom√°tico**: Elimina propiedades no permitidas en el DTO
- ‚úÖ **Errores detallados**: Formato estructurado con field-level errors
- ‚úÖ **Sistema de errores centralizado**: Usa `ValidationError` e `InternalServerError`
- ‚úÖ **Type-safe**: Reemplaza `req[type]` con instancia validada y tipada
- ‚úÖ **Conversi√≥n impl√≠cita**: Convierte tipos en query/params autom√°ticamente
- ‚úÖ **Sin Magic Numbers**: Usa constantes del sistema de errores
- ‚úÖ **Manejo robusto**: Captura errores de validaci√≥n y errores internos

## üéØ ¬øQu√© hace el ValidationPipe?

1. **Transforma** `req[type]` (body/query/params) a una instancia del DTO con `plainToInstance`
2. **Valida** la instancia con decoradores de `class-validator`
3. **Elimina** propiedades no permitidas (`whitelist: true`)
4. **Rechaza** peticiones con campos extra (`forbidNonWhitelisted: true`)
5. **Reemplaza** `req[type]` con la instancia validada para acceso tipado en controladores
6. **Delega** manejo de errores al `globalErrorHandler`

## üîß Uso

### Importaci√≥n

```typescript
import { ValidationPipe, ValidateBody, ValidateQuery, ValidateParams } from '@middleware/validation-pipe.js';
```

### Validaci√≥n de Body

```typescript
import { ValidateBody } from '@middleware/validation-pipe.js';
import { CreateProductDto } from '@api/products/dtos/CreateProductDto.js';

// En rutas
router.post('/products', ValidateBody(CreateProductDto), ProductController.create);

// En controlador - body ya est√° tipado
async create(req: Request, res: Response, next: NextFunction) {
  // req.body es instancia de CreateProductDto validada
  const product = await ProductService.create(req.body);
  res.status(HTTP_STATUS.CREATED).json(product);
}
```

### Validaci√≥n de Query Parameters

```typescript
import { ValidateQuery } from '@middleware/validation-pipe.js';
import { QueryProductDto } from '@api/products/dtos/QueryProductDto.js';

// Conversi√≥n autom√°tica de strings a n√∫meros/booleanos
router.get('/products', ValidateQuery(QueryProductDto), ProductController.getAll);

// QueryProductDto.ts
export class QueryProductDto {
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  page?: number; // "10" ‚Üí 10

  @IsOptional()
  @IsInt()
  @Type(() => Number)
  limit?: number;

  @IsOptional()
  @IsString()
  search?: string;
}
```

### Validaci√≥n de Route Parameters

```typescript
import { ValidateParams } from '@middleware/validation-pipe.js';
import { ParamProductDto } from '@api/products/dtos/ParamProductDto.js';

router.get('/products/:id', ValidateParams(ParamProductDto), ProductController.getById);

// ParamProductDto.ts
export class ParamProductDto {
  @IsUUID()
  id: string;
}
```

### Uso Avanzado con Opciones

```typescript
// Updates parciales - permite campos opcionales
router.patch(
  '/products/:id',
  ValidateBody(UpdateProductDto, { skipMissingProperties: true }),
  ProductController.update,
);

// Validaci√≥n por grupos
router.post('/products/draft', ValidateBody(ProductDto, { groups: ['draft'] }), ProductController.createDraft);

// Permitir propiedades extra (no recomendado)
router.post('/products/flexible', ValidateBody(ProductDto, { forbidNonWhitelisted: false }), ProductController.create);
```

## üìù Implementaci√≥n Actual

```typescript
import { plainToInstance } from 'class-transformer';
import { validate, type ValidationError as ClassValidatorError } from 'class-validator';
import type { Request, Response, NextFunction } from 'express';
import { VALIDATION_ERROR_MESSAGES } from '@constants/validation/index.js';
import { ValidationError, InternalServerError } from '@utils/errors.js';

export function ValidationPipe<T extends object>(
  dtoClass: ClassType<T>,
  type: ValidationType = 'body',
  options?: ValidationPipeOptions,
) {
  return async (req: Request, _res: Response, next: NextFunction): Promise<void> => {
    try {
      const dtoObject = plainToInstance(dtoClass, req[type], {
        enableImplicitConversion: type === 'query' || type === 'params',
        excludeExtraneousValues: false,
      });

      const errors = await validate(dtoObject, {
        whitelist: true,
        forbidNonWhitelisted: true,
        skipMissingProperties: false,
        ...options,
      });

      if (errors.length > 0) {
        const formattedErrors = formatValidationErrors(errors);
        throw new ValidationError(JSON.stringify(formattedErrors));
      }

      req[type] = dtoObject as unknown;
      next();
    } catch (error) {
      if (error instanceof ValidationError) {
        next(error);
      } else {
        next(new InternalServerError(VALIDATION_ERROR_MESSAGES.INTERNAL_VALIDATION_ERROR));
      }
    }
  };
}
```

## üéØ Flujo de Validaci√≥n

```
Request con body/query/params
    ‚Üì
ValidationPipe transforma a instancia DTO
    ‚Üì
Valida con decoradores class-validator
    ‚Üì
‚îú‚îÄ ¬øErrores de validaci√≥n?
‚îÇ   ‚îú‚îÄ S√ç ‚Üí throw new ValidationError(detalles)
‚îÇ   ‚îî‚îÄ NO ‚Üí req[type] = dtoObject tipado
    ‚Üì
‚îú‚îÄ Error interno?
‚îÇ   ‚îî‚îÄ S√ç ‚Üí throw new InternalServerError()
    ‚Üì
globalErrorHandler captura el error
    ‚Üì
Response con formato est√°ndar
```

## üì§ Respuestas de Ejemplo

### ‚úÖ Validaci√≥n Exitosa

```http
POST /api/products
Content-Type: application/json

{
  "title": "Product Name",
  "price": 29.99
}

HTTP/1.1 201 Created
{
  "id": "123",
  "title": "Product Name",
  "price": 29.99
}
```

### ‚ùå Errores de Validaci√≥n

```http
POST /api/products
Content-Type: application/json

{
  "title": "",
  "price": -10,
  "extraField": "not allowed"
}

HTTP/1.1 400 Bad Request
{
  "statusCode": 400,
  "message": "Validation error",
  "details": "[{\"field\":\"title\",\"constraints\":[\"title must be between 1 and 255 characters\"]},{\"field\":\"price\",\"constraints\":[\"price must be a positive number\"]},{\"field\":\"extraField\",\"constraints\":[\"property extraField should not exist\"]}]",
  "timestamp": "2025-10-10T12:34:56.789Z",
  "path": "/api/products"
}
```

## ‚öôÔ∏è Opciones de Configuraci√≥n

### `ValidationPipeOptions`

```typescript
interface ValidationPipeOptions {
  whitelist?: boolean; // Elimina propiedades no decoradas (default: true)
  forbidNonWhitelisted?: boolean; // Rechaza propiedades extra (default: true)
  skipMissingProperties?: boolean; // Permite campos opcionales (default: false)
  enableImplicitConversion?: boolean; // Convierte tipos autom√°ticamente (default: auto para query/params)
  groups?: string[]; // Valida solo decoradores con grupos espec√≠ficos
}
```

### Casos de Uso por Opci√≥n

| Opci√≥n                     | Create | Update Parcial | Query/Params |
| -------------------------- | ------ | -------------- | ------------ |
| `whitelist`                | ‚úÖ     | ‚úÖ             | ‚úÖ           |
| `forbidNonWhitelisted`     | ‚úÖ     | ‚úÖ             | ‚úÖ           |
| `skipMissingProperties`    | ‚ùå     | ‚úÖ             | ‚úÖ           |
| `enableImplicitConversion` | ‚ùå     | ‚ùå             | ‚úÖ (auto)    |

## üé® Mejores Pr√°cticas Aplicadas

### ‚úÖ Sistema de Errores Centralizado

```typescript
// ‚ùå ANTES: Respuesta manual en middleware
return res.status(400).json({
  success: false,
  message: 'Validation failed',
  errors: formattedErrors,
});

// ‚úÖ DESPU√âS: Delega al globalErrorHandler
throw new ValidationError(JSON.stringify(formattedErrors));
// globalErrorHandler se encarga del formato de respuesta
```

### ‚úÖ Manejo de Errores Robusto

```typescript
// Distingue entre errores de validaci√≥n y errores internos
catch (error) {
  if (error instanceof ValidationError) {
    next(error); // Error operacional (400)
  } else {
    next(new InternalServerError(...)); // Error no operacional (500)
  }
}
```

### ‚úÖ Type Safety Completo

```typescript
// ‚ùå ANTES: any types
req.body = dtoObject as any;

// ‚úÖ DESPU√âS: unknown + type assertion
req[type] = dtoObject as unknown;
// Controlador recibe tipo correcto del DTO
```

### ‚úÖ Sin Magic Numbers

```typescript
// ‚ùå ANTES: Status codes hardcodeados
res.status(400).json(...);
res.status(500).json(...);

// ‚úÖ DESPU√âS: Usa constantes del sistema
throw new ValidationError(...); // Usa HTTP_STATUS.BAD_REQUEST internamente
throw new InternalServerError(...); // Usa HTTP_STATUS.INTERNAL_SERVER_ERROR
```

### ‚úÖ Evita Conflictos de Nombres

```typescript
// Renombra ValidationError de class-validator
import { validate, type ValidationError as ClassValidatorError } from 'class-validator';
// Usa ValidationError del sistema de errores
import { ValidationError } from '@utils/errors.js';
```

## üìä Formato de Errores Detallado

### Errores Anidados

```typescript
// DTO con nested objects
class AddressDto {
  @IsString()
  street: string;

  @IsInt()
  @Type(() => Number)
  number: number;
}

class CreateUserDto {
  @IsEmail()
  email: string;

  @ValidateNested()
  @Type(() => AddressDto)
  address: AddressDto;
}

// Error response
{
  "statusCode": 400,
  "message": "Validation error",
  "details": "[
    {\"field\":\"email\",\"constraints\":[\"email must be a valid email\"]},
    {\"field\":\"address.street\",\"constraints\":[\"street must be a string\"]},
    {\"field\":\"address.number\",\"constraints\":[\"number must be an integer\"]}
  ]",
  "timestamp": "2025-10-10T12:34:56.789Z",
  "path": "/api/users"
}
```

## üöÄ Ventajas del Sistema

1. **üéØ Validaci√≥n Consistente**: Mismo formato de error en toda la API
2. **üîç Debugging Mejorado**: Logs estructurados con contexto completo
3. **üìä Type Safety**: Controladores reciben datos tipados y validados
4. **üõ°Ô∏è Seguridad**: Whitelist previene mass assignment vulnerabilities
5. **üßπ Clean Code**: L√≥gica de validaci√≥n centralizada, no duplicada
6. **üìù Mantenibilidad**: Cambios en DTOs autom√°ticamente actualizan validaciones
7. **üîí Robustez**: Distingue errores operacionales de crashes internos

## üîó Integraci√≥n con el Ecosistema

- **DTOs**: Clases con decoradores de `class-validator`
- **ValidationError**: Error operacional (400) del sistema centralizado
- **globalErrorHandler**: Captura y formatea todos los errores
- **httpLogger**: Registra peticiones y errores con Pino
- **Constantes**: `VALIDATION_ERROR_MESSAGES` centralizadas

## üìö Referencias

- [class-validator Documentation](https://github.com/typestack/class-validator)
- [class-transformer Documentation](https://github.com/typestack/class-transformer)
- Sistema de Errores: `src/utils/errors.ts`
- Global Error Handler: `src/middleware/errorHandler.ts`

Buenas pr√°cticas:

- Para endpoints de actualizaci√≥n parcial (`PATCH`/`PUT` con campos opcionales), usa `skipMissingProperties: true` o aplica `@IsOptional()` en el DTO de update.
- Mant√©n los mensajes de error en el idioma del proyecto (aqu√≠: espa√±ol) o usa un sistema i18n.
- Evita exponer detalles internos en producci√≥n; transforma constraints si es necesario.
