# Sistema de DTOs y Validaci√≥n Escalable

## üìñ Tabla de Contenidos

- [Introducci√≥n](#introducci√≥n)
- [Estructura de Archivos](#estructura-de-archivos)
- [ValidationPipe Mejorado](#validationpipe-mejorado)
- [Tipos de DTOs](#tipos-de-dtos)
- [Uso en Rutas](#uso-en-rutas)
- [Ejemplos Pr√°cticos](#ejemplos-pr√°cticos)
- [Mejores Pr√°cticas](#mejores-pr√°cticas)

---

## üéØ Introducci√≥n

Este proyecto implementa un sistema de validaci√≥n escalable usando:

- **class-validator**: Decoradores para validar propiedades
- **class-transformer**: Transformar objetos planos a instancias de clases
- **DTOs (Data Transfer Objects)**: Definir contratos de entrada/salida
- **ValidationPipe**: Middleware flexible para validar body, query y params

---

## üìÅ Estructura de Archivos

```
src/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ products/
‚îÇ       ‚îú‚îÄ‚îÄ productModel.ts          # Entity TypeORM
‚îÇ       ‚îú‚îÄ‚îÄ productController.ts     # Controlador
‚îÇ       ‚îú‚îÄ‚îÄ ProductService.ts        # L√≥gica de negocio
‚îÇ       ‚îú‚îÄ‚îÄ ProductRoutes.ts         # Rutas con validaci√≥n
‚îÇ       ‚îî‚îÄ‚îÄ dtos/
‚îÇ           ‚îú‚îÄ‚îÄ CreateProductDto.ts  # DTO para POST
‚îÇ           ‚îú‚îÄ‚îÄ UpdateProductDto.ts  # DTO para PUT/PATCH
‚îÇ           ‚îú‚îÄ‚îÄ QueryProductDto.ts   # DTO para query params
‚îÇ           ‚îî‚îÄ‚îÄ ParamProductDto.ts   # DTO para route params
‚îî‚îÄ‚îÄ middleware/
    ‚îî‚îÄ‚îÄ validation-pipe.ts           # Middleware de validaci√≥n
```

---

## ‚öôÔ∏è ValidationPipe Mejorado

### Caracter√≠sticas

‚úÖ **Valida 3 tipos de datos**:

- `body` - Cuerpo de la petici√≥n (POST, PUT, PATCH)
- `query` - Query parameters (GET con filtros)
- `params` - Route parameters (/:id)

‚úÖ **Auto-transformaci√≥n de tipos**:

- Convierte strings a n√∫meros autom√°ticamente para query/params
- Usa decoradores `@Transform()` para conversiones personalizadas

‚úÖ **Formato de errores consistente**:

```json
{
  "success": false,
  "message": "Errores de validaci√≥n en el cuerpo de la petici√≥n",
  "errors": [
    {
      "field": "title",
      "constraints": ["El t√≠tulo es obligatorio", "El t√≠tulo debe tener entre 1 y 255 caracteres"]
    }
  ],
  "statusCode": 400
}
```

### Funciones Disponibles

```typescript
// Funci√≥n principal (flexible)
ValidationPipe(DtoClass, 'body' | 'query' | 'params', options?)

// Aliases (m√°s legibles)
ValidateBody(DtoClass, options?)
ValidateQuery(DtoClass, options?)
ValidateParams(DtoClass, options?)
```

### Opciones

```typescript
interface ValidationPipeOptions {
  whitelist?: boolean; // Eliminar propiedades no definidas en DTO
  forbidNonWhitelisted?: boolean; // Error si hay propiedades extra
  skipMissingProperties?: boolean; // Permitir campos opcionales sin validar
  enableImplicitConversion?: boolean; // Auto-transformar tipos (default: true para query/params)
  groups?: string[]; // Grupos de validaci√≥n
}
```

---

## üì¶ Tipos de DTOs

### 1. CreateProductDto (POST)

**Ubicaci√≥n**: `src/api/products/dtos/CreateProductDto.ts`

**Prop√≥sito**: Validar datos al crear un producto

**Campos obligatorios**:

- `documentId` (string)
- `title` (string)
- `SKU` (string)
- `vertical` (array de Verticals)
- `type` (ProductType enum)
- `stripeCrm` (StripeCrm enum)

**Ejemplo**:

```typescript
import { IsString, IsNotEmpty, IsEnum, IsArray, Length } from 'class-validator';

export class CreateProductDto {
  @IsString({ message: 'El t√≠tulo debe ser un texto' })
  @IsNotEmpty({ message: 'El t√≠tulo es obligatorio' })
  @Length(1, 255, { message: 'El t√≠tulo debe tener entre 1 y 255 caracteres' })
  title!: string;

  @IsArray({ message: 'El vertical debe ser un array' })
  @ArrayMinSize(1, { message: 'Debe seleccionar al menos un vertical' })
  @IsEnum(Verticals, { each: true, message: 'Cada vertical debe ser un valor v√°lido' })
  vertical!: Verticals[];
}
```

### 2. UpdateProductDto (PUT/PATCH)

**Ubicaci√≥n**: `src/api/products/dtos/UpdateProductDto.ts`

**Prop√≥sito**: Validar datos al actualizar un producto

**Caracter√≠sticas**:

- Todos los campos son opcionales (`@IsOptional()`)
- Mismas validaciones que CreateProductDto pero sin `@IsNotEmpty()`

**Uso en rutas**:

```typescript
router.put('/:id', ValidateBody(UpdateProductDto, { skipMissingProperties: true }), controller.update);
```

### 3. QueryProductDto (GET con filtros)

**Ubicaci√≥n**: `src/api/products/dtos/QueryProductDto.ts`

**Prop√≥sito**: Validar query parameters en endpoints de consulta

**Ejemplo**:

```typescript
export class QueryProductDto {
  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @IsOptional()
  page?: number;

  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @Max(100)
  @IsOptional()
  limit?: number;
}
```

**Uso**:

```bash
GET /api/products?type=Libro&page=1&limit=10
```

### 4. ParamProductDto (Route params)

**Ubicaci√≥n**: `src/api/products/dtos/ParamProductDto.ts`

**Prop√≥sito**: Validar par√°metros de ruta (/:id)

**Ejemplo**:

```typescript
export class ParamProductDto {
  @Transform(({ value }) => parseInt(value, 10))
  @IsInt({ message: 'El ID debe ser un n√∫mero entero' })
  @Min(1, { message: 'El ID debe ser un n√∫mero positivo' })
  @IsNotEmpty({ message: 'El ID es obligatorio' })
  id!: number;
}
```

---

## üõ£Ô∏è Uso en Rutas

### Ejemplo Completo

```typescript
// ProductRoutes.ts
import { Router } from 'express';
import { ValidateBody, ValidateQuery, ValidateParams } from '@middleware/validation-pipe.js';
import { CreateProductDto } from './dtos/CreateProductDto.js';
import { UpdateProductDto } from './dtos/UpdateProductDto.js';
import { QueryProductDto } from './dtos/QueryProductDto.js';
import { ParamProductDto } from './dtos/ParamProductDto.js';

const router = Router();

// GET /api/products?type=Libro&page=1&limit=10
router.get('/', ValidateQuery(QueryProductDto), controller.findAll);

// GET /api/products/:id
router.get('/:id', ValidateParams(ParamProductDto), controller.findOne);

// POST /api/products
router.post('/', ValidateBody(CreateProductDto), controller.create);

// PUT /api/products/:id
router.put(
  '/:id',
  ValidateParams(ParamProductDto),
  ValidateBody(UpdateProductDto, { skipMissingProperties: true }),
  controller.update,
);

// DELETE /api/products/:id
router.delete('/:id', ValidateParams(ParamProductDto), controller.delete);

export default router;
```

---

## üí° Ejemplos Pr√°cticos

### Ejemplo 1: POST /api/products (Crear producto)

**Request**:

```bash
POST /api/products
Content-Type: application/json

{
  "documentId": "DOC123",
  "title": "M√°ster en Cirug√≠a",
  "SKU": "MAH-001",
  "vertical": ["Cirug√≠a"],
  "type": "Programa largo",
  "stripeCrm": "Alebat"
}
```

**Validaci√≥n aplicada**: `CreateProductDto`

**Si falta un campo**:

```json
{
  "success": false,
  "message": "Errores de validaci√≥n en el cuerpo de la petici√≥n",
  "errors": [
    {
      "field": "title",
      "constraints": ["El t√≠tulo es obligatorio"]
    }
  ],
  "statusCode": 400
}
```

### Ejemplo 2: GET /api/products?type=Libro&page=2&limit=20

**Request**:

```bash
GET /api/products?type=Libro&page=2&limit=20
```

**Validaci√≥n aplicada**: `QueryProductDto`

**Transformaci√≥n autom√°tica**:

- `page` se convierte de string `"2"` a n√∫mero `2`
- `limit` se convierte de string `"20"` a n√∫mero `20`

**Si page es inv√°lido**:

```bash
GET /api/products?page=abc
```

**Response**:

```json
{
  "success": false,
  "message": "Errores de validaci√≥n en los par√°metros de consulta",
  "errors": [
    {
      "field": "page",
      "constraints": ["La p√°gina debe ser un n√∫mero entero"]
    }
  ],
  "statusCode": 400
}
```

### Ejemplo 3: PUT /api/products/:id (Actualizar producto)

**Request**:

```bash
PUT /api/products/5
Content-Type: application/json

{
  "title": "Nuevo t√≠tulo",
  "isPremium": true
}
```

**Validaci√≥n aplicada**:

1. `ParamProductDto` valida que `id=5` es un n√∫mero v√°lido
2. `UpdateProductDto` valida que los campos enviados son correctos
3. Los campos no enviados se ignoran (`skipMissingProperties: true`)

---

## ‚úÖ Mejores Pr√°cticas

### 1. Separar DTOs por operaci√≥n

```
‚úÖ CORRECTO
‚îú‚îÄ‚îÄ CreateProductDto.ts  # POST - campos obligatorios
‚îú‚îÄ‚îÄ UpdateProductDto.ts  # PUT/PATCH - campos opcionales
‚îú‚îÄ‚îÄ QueryProductDto.ts   # GET - filtros y paginaci√≥n
‚îî‚îÄ‚îÄ ParamProductDto.ts   # /:id - validaci√≥n de params

‚ùå INCORRECTO
‚îî‚îÄ‚îÄ ProductDto.ts  # Un solo DTO para todo
```

### 2. Usar decoradores con mensajes en espa√±ol

```typescript
‚úÖ CORRECTO
@IsString({ message: 'El t√≠tulo debe ser un texto' })
@IsNotEmpty({ message: 'El t√≠tulo es obligatorio' })
title!: string;

‚ùå INCORRECTO
@IsString()  // Sin mensaje personalizado
title!: string;
```

### 3. Validar enums correctamente

```typescript
‚úÖ CORRECTO
@IsEnum(ProductType, { message: 'El tipo de producto debe ser un valor v√°lido' })
type!: ProductType;

‚ùå INCORRECTO
@IsString()  // Permite cualquier string
type!: string;
```

### 4. Transformar tipos en query/params

```typescript
‚úÖ CORRECTO
@Transform(({ value }) => parseInt(value, 10))
@IsInt()
@Min(1)
page?: number;

‚ùå INCORRECTO
@IsInt()  // No transforma, siempre ser√° string
page?: number;
```

### 5. Aplicar m√∫ltiples validaciones en rutas

```typescript
‚úÖ CORRECTO - Validar params Y body
router.put(
  '/:id',
  ValidateParams(ParamProductDto),
  ValidateBody(UpdateProductDto),
  controller.update
);

‚ùå INCORRECTO - Solo validar body
router.put('/:id', ValidateBody(UpdateProductDto), controller.update);
```

### 6. Usar opciones apropiadas para cada caso

```typescript
// POST - Estricto, todos los campos requeridos
ValidateBody(CreateProductDto);

// PUT/PATCH - Permitir campos opcionales
ValidateBody(UpdateProductDto, { skipMissingProperties: true });

// Query - Auto-transformar tipos
ValidateQuery(QueryProductDto); // enableImplicitConversion: true por defecto
```

### 7. Documentar rutas con comentarios

```typescript
/**
 * @route   POST /api/products
 * @desc    Crear un nuevo producto
 * @access  Private
 * @body    CreateProductDto
 */
router.post('/', ValidateBody(CreateProductDto), controller.create);
```

---

## üöÄ C√≥mo Crear DTOs desde un Model

### Paso 1: Analizar el Model (Entity)

```typescript
// productModel.ts
@Entity('products')
export class Product {
  @PrimaryGeneratedColumn()
  id!: number; // ‚ùå No incluir en CreateDto (auto-generado)

  @Column({ nullable: false })
  title!: string; // ‚úÖ Obligatorio en CreateDto

  @Column({ nullable: true })
  slug?: string; // ‚úÖ Opcional en CreateDto

  @Column({ type: 'enum', enum: ProductType })
  type!: ProductType; // ‚úÖ Validar con @IsEnum

  @CreateDateColumn()
  createdAt!: Date; // ‚ùå No incluir en CreateDto (auto-generado)
}
```

### Paso 2: Crear CreateDto

```typescript
// dtos/CreateProductDto.ts
export class CreateProductDto {
  // Campos obligatorios (nullable: false)
  @IsString()
  @IsNotEmpty()
  title!: string;

  @IsEnum(ProductType)
  @IsNotEmpty()
  type!: ProductType;

  // Campos opcionales (nullable: true)
  @IsString()
  @IsOptional()
  slug?: string;

  // ‚ùå NO incluir:
  // - id (auto-generado)
  // - createdAt, updatedAt (timestamps autom√°ticos)
}
```

### Paso 3: Crear UpdateDto (copiar CreateDto pero todo opcional)

```typescript
// dtos/UpdateProductDto.ts
export class UpdateProductDto {
  @IsString()
  @IsOptional()
  title?: string;

  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @IsString()
  @IsOptional()
  slug?: string;
}
```

### Paso 4: Crear QueryDto (para filtros)

```typescript
// dtos/QueryProductDto.ts
export class QueryProductDto {
  // Filtros
  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @IsString()
  @IsOptional()
  slug?: string;

  // Paginaci√≥n
  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @IsOptional()
  page?: number;

  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @Max(100)
  @IsOptional()
  limit?: number;
}
```

### Paso 5: Crear ParamDto (para /:id)

```typescript
// dtos/ParamProductDto.ts
export class ParamProductDto {
  @Transform(({ value }) => parseInt(value, 10))
  @IsInt()
  @Min(1)
  @IsNotEmpty()
  id!: number;
}
```

---

## üéì Resumen

| DTO           | Uso          | Campos                              | Validaci√≥n                       |
| ------------- | ------------ | ----------------------------------- | -------------------------------- |
| **CreateDto** | POST         | Obligatorios + opcionales del model | Estricta                         |
| **UpdateDto** | PUT/PATCH    | Todos opcionales                    | `skipMissingProperties: true`    |
| **QueryDto**  | GET          | Filtros + paginaci√≥n                | `enableImplicitConversion: true` |
| **ParamDto**  | /:id, /:slug | Par√°metros de ruta                  | Transformar a tipo correcto      |

---

## üìö Recursos

- [class-validator](https://github.com/typestack/class-validator)
- [class-transformer](https://github.com/typestack/class-transformer)
- [TypeORM](https://typeorm.io/)
- [Express.js](https://expressjs.com/)

---

**‚úÖ Sistema implementado y listo para usar**

Ahora puedes crear DTOs escalables para cualquier m√≥dulo siguiendo este patr√≥n.
